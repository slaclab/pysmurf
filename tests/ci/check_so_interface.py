import ast
# functions and their arguments to check
# specified here: https://www.overleaf.com/project/5e837cac9659910001e5f71e
# could move this to a file
#to complete: work on functions and arguments to check file and spec_args dictionary
interface = {
    "python/pysmurf/client/tune/smurf_tune.py": {  # file
        "SmurfTuneMixin": {                        # class
            "find_freq": [],                       # function and args
        }
    },
}

spec_args = {
    "setup": [
        
    ], 
    "set_amplifier_bias": [
        
    ], 
    "set_cryo_card_ps_en": [
        
    ], 
    "which_on": [
        
    ], 
    "band_off": [

    ], 
    "channel_off": [

    ], 
    "full_band_resp": [

    ], 
    "find_freq": [

    ],
    "setup_notches": [

    ], 
    "run_serial_gradient_descent": [

    ], 
    "run_serial_eta_scan": [

    ], 
    "plot_tune_summary": [

    ], 
    "tracking_setup": [

    ], 
    "set_amplitude_scale_array": [

    ],
    "set_tes_bias_bipolar_array": [

    ], 
    "set_tes_bias_high_current": [

    ], 
    "set_tes_bias_low_current": [

    ], 
    "set_mode_dc" "set_mode_ac": [

    ], 
    "flux_ramp_setup": [

    ],
    "set_stream_enable": [

    ], 
    "take_stream_data": [

    ], 
    "take_noise_psd": [

    ], 
    "stream_data_on": [

    ], 
    "stream_data_off": [

    ], 
    "read_stream_data": [

    ],
    "set_downsample_filter": [

    ], 
    "run_iv": [

    ], 
    "analyze_iv": [

    ]
}
freeze = {}

with open('tests/ci/frozen_functions.py', 'r') as fh:   #opens file "fname", in read mode 'r', to be used in code as "fh"
    frozen = ast.parse(fh.read())
    for node in ast.walk(frozen):
        if isinstance(node, ast.FunctionDef) and node.name in spec_args.keys():
            freeze.update({node.name: node})
print(freeze.items())
"""
*** ==> I found this function in smurf_tune.py
frozen functions list:

SETUP FUNCTIONS
setup
set_amplifier_bias
set_cryo_card_ps_en
which_on
band_off
channel_off

TUNING FUNCTIONS
full_band_resp ***
find_freq ***
setup_notches ***
run_serial_gradient_descent
run_serial_eta_scan
plot_tune_summary ***
tracking_setup ***
set_amplitude_scale_array

TES/FLUX RAMP FUNCTIONS
set_tes_bias_bipolar_array
set_tes_bias_high_current
set_tes_bias_low_current
set_mode_dc
set_mode_ac
flux_ramp_setup ***

DATA ACQUISITION FUNCTIONS
set_stream_enable
take_stream_data
take_noise_psd
stream_data_on
stream_data_off
read_stream_data
set_downsample_filter

IV FUNCTIONS
run_iv
analyze_iv

DATA OUTPUTS TO DISK
tune files generated when new resonators are found
channel mapping file format
.dat noise files - generated by take_stream_data
iv_files - generated by run_iv"

"""
def compare_args(found, spec_args):
    for func_name, func_node in found.items():
        if func_name not in spec_args:
            print(func_name + " not in specified functions")
            continue
        
        spec_func = spec_args[func_name]
        
        # Handle the case where spec_func is a list
        if isinstance(spec_func, list):
            if len(spec_func) == 0:
                print(f"No specification for {func_name}")
                continue
            spec_func = spec_func[0]  # Assume the function is the first item in the list
        
        # Extract arguments from the AST node
        found_args = [arg.arg for arg in func_node.args.args]
        found_defaults = [ast.unparse(d) if d else None for d in func_node.args.defaults]
        
        # Extract arguments from the spec function
        spec_sig = ast.parse(f"def {func_name}{ast.get_source_segment(spec_func, spec_func.args)}:pass").body[0]
        spec_args_list = [arg.arg for arg in spec_sig.args.args]
        spec_defaults = [ast.unparse(d) if d else None for d in spec_sig.args.defaults]
        
        # Compare arguments
        if found_args != spec_args_list:
            print(f"Mismatch in arguments for function {func_name}")
            print(f"Found: {found_args}")
            print(f"Expected: {spec_args_list}")
            return False
        
        # Compare default values
        if found_defaults != spec_defaults:
            print(f"Mismatch in default values for function {func_name}")
            print(f"Found: {found_defaults}")
            print(f"Expected: {spec_defaults}")
            return False
    
    return True

if __name__ == "__main__":   #if this is the main thing being run
    for fname, spec in interface.items():   #loop over file names "fname" as keys and "spec" as values in dictionary called "interface"
        print(interface.items())
        with open(fname, 'r') as fh:   #opens file "fname", in read mode 'r', to be used in code as "fh"
            tree = ast.parse(fh.read()) #parsing contents of file into abstract syntax tree
            notfound = []
            found = {}
            dump = ast.dump(tree)
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef) and node.name in spec_args.keys():
                found.update({node.name: node})
        for key in spec_args:
            if key not in found:
                notfound.append(key)          
        print("FOUND:")
        print(found.keys())
        print("NOT FOUND:")
        print(notfound)
        #compare arguments
        assert compare_args(found, spec_args)
        #print(ast.dump(found.get('find_freq')))
pass
